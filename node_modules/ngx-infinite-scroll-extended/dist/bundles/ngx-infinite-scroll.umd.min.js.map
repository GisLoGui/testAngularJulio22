{"version":3,"file":"ngx-infinite-scroll.umd.min.js","sources":["../../src/services/position-resolver.ts","../../src/services/scroll-register.ts","../../src/services/scroll-resolver.ts","../../src/services/axis-resolver.ts","../../src/modules/infinite-scroll.directive.ts","../../src/modules/ngx-infinite-scroll.module.ts"],"sourcesContent":["import { Injectable, ElementRef } from '@angular/core';\nimport { AxisResolver } from './axis-resolver';\nimport { ContainerRef, IPositionElements, IPositionStats, IResolver } from '../models';\nexport class PositionResolver {\n/**\n * @param {?} options\n * @return {?}\n */\ncreate(options: IPositionElements): IResolver {\n    const /** @type {?} */ isWindow = this.isElementWindow(options.windowElement);\n    const /** @type {?} */ resolver: IResolver = {\n      axis: options.axis,\n      container: this.defineContainer(options.windowElement, isWindow),\n      isWindow,\n    };\n    return resolver;\n  }\n/**\n * @param {?} windowElement\n * @param {?} isContainerWindow\n * @return {?}\n */\ndefineContainer(windowElement: ContainerRef, isContainerWindow: boolean) {\n    const /** @type {?} */ container = (isContainerWindow || !windowElement.nativeElement)\n      ? windowElement\n      : windowElement.nativeElement;\n    return container;\n  }\n/**\n * @param {?} windowElement\n * @return {?}\n */\nisElementWindow(windowElement: ContainerRef): boolean {\n    const /** @type {?} */ isWindow = Object.prototype.toString.call(windowElement).includes('Window');\n    return isWindow;\n  }\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\ngetDocumentElement(isContainerWindow: boolean, windowElement) {\n    return isContainerWindow\n      ? windowElement.document.documentElement\n      : null;\n  }\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\ncalculatePoints (element: ElementRef, resolver: IResolver) {\n    return resolver.isWindow\n      ? this.calculatePointsForWindow(element, resolver)\n      : this.calculatePointsForElement(element, resolver);\n  }\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\ncalculatePointsForWindow (element: ElementRef, resolver: IResolver): IPositionStats {\n    const { axis, container, isWindow } = resolver;\n    const /** @type {?} */ offsetHeightKey = axis.offsetHeightKey();\n    const /** @type {?} */ clientHeightKey = axis.clientHeightKey();\n    const /** @type {?} */ topKey = axis.topKey();\n    // container's height\n    const /** @type {?} */ height = this.height(container, isWindow, offsetHeightKey, clientHeightKey);\n    // scrolled until now / current y point\n    const /** @type {?} */ scrolledUntilNow = height + this.pageYOffset(this.getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    const /** @type {?} */ nativeElementHeight = this.height(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    const /** @type {?} */ totalToScroll = this.offsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n    return { height, scrolledUntilNow, totalToScroll };\n  }\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\ncalculatePointsForElement (element: ElementRef, resolver: IResolver) {\n    const { axis, container, isWindow } = resolver;\n    const /** @type {?} */ offsetHeightKey = axis.offsetHeightKey();\n    const /** @type {?} */ clientHeightKey = axis.clientHeightKey();\n    const /** @type {?} */ scrollTop = axis.scrollTopKey();\n    const /** @type {?} */ scrollHeight = axis.scrollHeightKey();\n    const /** @type {?} */ topKey = axis.topKey();\n\n    const /** @type {?} */ height = this.height(container, isWindow, offsetHeightKey, clientHeightKey);\n    // perhaps use this.container.offsetTop instead of 'scrollTop'\n    const /** @type {?} */ scrolledUntilNow = container[scrollTop];\n    let /** @type {?} */ containerTopOffset = 0;\n    const /** @type {?} */ offsetTop = this.offsetTop(container, axis, isWindow);\n    if (offsetTop !== void 0) {\n      containerTopOffset = offsetTop;\n    }\n    const /** @type {?} */ totalToScroll = container[scrollHeight];\n    return { height, scrolledUntilNow, totalToScroll };\n  }\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nprivate height (elem: any, isWindow: boolean, offsetHeightKey: string, clientHeightKey: string) {\n    if (isNaN(elem[offsetHeightKey])) {\n      return this.getDocumentElement(isWindow, elem)[clientHeightKey];\n    } else {\n      return elem[offsetHeightKey];\n    }\n  }\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nprivate offsetTop (elem: ContainerRef, axis: AxisResolver, isWindow: boolean) {\n    const /** @type {?} */ topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) { // || elem.css('none')) {\n      return;\n    }\n    return elem.getBoundingClientRect()[topKey] + this.pageYOffset(elem, axis, isWindow);\n  }\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nprivate pageYOffset (elem: ContainerRef, axis: AxisResolver, isWindow: boolean) {\n    const /** @type {?} */ pageYOffset = axis.pageYOffsetKey();\n    const /** @type {?} */ scrollTop = axis.scrollTopKey();\n    const /** @type {?} */ offsetTop = axis.offsetTopKey();\n\n    if (isNaN(window[pageYOffset])) {\n      return this.getDocumentElement(isWindow, elem)[scrollTop];\n    } else if (elem.ownerDocument) {\n      return elem.ownerDocument.defaultView[pageYOffset];\n    } else {\n      return elem[offsetTop];\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction PositionResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nPositionResolver.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nPositionResolver.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { ContainerRef, IPositionStats, IScrollStats } from '../models';\nimport { Injectable, ElementRef } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport'rxjs/add/observable/fromEvent';\nimport'rxjs/add/observable/of';\nimport'rxjs/add/operator/sampleTime';\nimport'rxjs/add/operator/filter';\nimport'rxjs/add/operator/mergeMap';\n\nexport interface IScrollRegisterConfig {\n  container: ContainerRef;\n  throttleDuration: number;\n  filterBefore: () => boolean;\n  mergeMap: Function;\n  scrollHandler: (value: any) => void;\n}\nexport class ScrollRegister {\n/**\n * @param {?} options\n * @return {?}\n */\nattachEvent (options: IScrollRegisterConfig): Subscription {\n    const /** @type {?} */ scroller$: Subscription = Observable.fromEvent(options.container, 'scroll')\n      .sampleTime(options.throttleDuration)\n      .filter(options.filterBefore)\n      .mergeMap((ev: any) => Observable.of(options.mergeMap(ev)))\n      .subscribe(options.scrollHandler);\n    return scroller$;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollRegister_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollRegister.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollRegister.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { IPositionStats, IScrollerConfig } from '../models';\nimport { Injectable } from '@angular/core';\nexport class ScrollResolver {\npublic lastScrollPosition: number = 0;\n/**\n * @param {?} container\n * @param {?} config\n * @param {?} scrollingDown\n * @return {?}\n */\nshouldScroll (container: IPositionStats, config: IScrollerConfig, scrollingDown: boolean) {\n    const /** @type {?} */ distance = config.distance;\n    const /** @type {?} */ scrollUpBy = config.scrollUpBy;\n    let /** @type {?} */ remaining: number;\n    let /** @type {?} */ containerBreakpoint: number;\n    if (scrollingDown) {\n      containerBreakpoint = container.height * distance.down + 1;\n      remaining = container.totalToScroll - container.scrolledUntilNow;\n    } else {\n      containerBreakpoint = container.height * distance.up + 1;\n      if (scrollUpBy === false) {\n        remaining = container.scrolledUntilNow;\n      } else {\n        remaining = this.lastScrollPosition - container.scrolledUntilNow;\n      }\n    }\n    const /** @type {?} */ shouldScroll: boolean = remaining <= containerBreakpoint;\n    this.lastScrollPosition = container.scrolledUntilNow;\n    return shouldScroll;\n  }\n/**\n * @param {?} container\n * @return {?}\n */\nisScrollingDown (container: IPositionStats) {\n    return this.lastScrollPosition < container.scrolledUntilNow;\n  }\n/**\n * @param {?} container\n * @param {?} config\n * @return {?}\n */\ngetScrollStats (container: IPositionStats, config: IScrollerConfig) {\n    const /** @type {?} */ isScrollingDown = this.isScrollingDown(container);\n    const /** @type {?} */ shouldScroll = this.shouldScroll(container, config, isScrollingDown);\n    return { isScrollingDown, shouldScroll };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollResolver.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollResolver.ctorParameters;\n/** @type {?} */\nScrollResolver.prototype.lastScrollPosition;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\nexport class AxisResolver {\n/**\n * @param {?=} vertical\n */\nconstructor(private vertical: boolean = true) {\n  }\n/**\n * @return {?}\n */\nclientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }\n/**\n * @return {?}\n */\noffsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }\n/**\n * @return {?}\n */\nscrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }\n/**\n * @return {?}\n */\npageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }\n/**\n * @return {?}\n */\noffsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }\n/**\n * @return {?}\n */\nscrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }\n/**\n * @return {?}\n */\ntopKey() { return this.vertical ? 'top' : 'left'; }\n}\n\nfunction AxisResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nAxisResolver.prototype.vertical;\n}\n\n","import { InfiniteScrollEvent, IScrollStats, IPositionStats, IResolver } from '../models';\nimport {\n  Directive, ElementRef, Input, Output,\n  EventEmitter, OnDestroy, OnInit,\n  SimpleChanges, NgZone\n} from '@angular/core';\nimport { PositionResolver } from '../services/position-resolver';\nimport { ScrollRegister, IScrollRegisterConfig } from '../services/scroll-register';\nimport { ScrollResolver } from '../services/scroll-resolver';\nimport { AxisResolver } from '../services/axis-resolver';\n\nimport { Subscription } from 'rxjs/Subscription';\nexport class InfiniteScrollDirective implements OnDestroy, OnInit {\n   scrolled = new EventEmitter<InfiniteScrollEvent>();\n   scrolledUp = new EventEmitter<InfiniteScrollEvent>();\n\n   infiniteScrollDistance: number = 2;\n   infiniteScrollUpDistance: number = 1.5;\n   infiniteScrollThrottle: number = 300;\n   infiniteScrollDisabled: boolean = false;\n   infiniteScrollContainer: any = null;\n   scrollWindow: boolean = true;\n   immediateCheck: boolean = false;\n   horizontal: boolean = false;\n   alwaysCallback: boolean = false;\n   scrollUpBy: boolean = false;\nprivate disposeScroller: Subscription;\n/**\n * @param {?} element\n * @param {?} zone\n * @param {?} positionResolver\n * @param {?} scrollRegister\n * @param {?} scrollerResolver\n */\nconstructor(\nprivate element: ElementRef,\nprivate zone: NgZone,\nprivate positionResolver: PositionResolver,\nprivate scrollRegister: ScrollRegister,\nprivate scrollerResolver: ScrollResolver\n  ) {}\n/**\n * @return {?}\n */\nngOnInit() {\n    if (typeof window !== 'undefined') {\n      this.zone.runOutsideAngular(() => {\n        const /** @type {?} */ containerElement = this.resolveContainerElement();\n        const /** @type {?} */ resolver = this.positionResolver.create({\n          axis: new AxisResolver(!this.horizontal),\n          windowElement: containerElement,\n        });\n        const /** @type {?} */ options: IScrollRegisterConfig = {\n          container: resolver.container,\n          filterBefore: () => !this.infiniteScrollDisabled,\n          mergeMap: () => this.positionResolver.calculatePoints(this.element, resolver),\n          scrollHandler: (container: IPositionStats) => this.handleOnScroll(container),\n          throttleDuration: this.infiniteScrollThrottle\n        };\n        this.disposeScroller = this.scrollRegister.attachEvent(options);\n      });\n    }\n  }\n/**\n * @param {?} container\n * @return {?}\n */\nhandleOnScroll(container: IPositionStats) {\n    const /** @type {?} */ distance = {\n      down: this.infiniteScrollDistance,\n      up: this.infiniteScrollUpDistance,\n    };\n    const /** @type {?} */ scrollUpBy: boolean = this.scrollUpBy;\n    const /** @type {?} */ scrollStats: IScrollStats = this.scrollerResolver.getScrollStats(container, { distance, scrollUpBy });\n    if (this.shouldTriggerEvents(scrollStats.shouldScroll)) {\n      const /** @type {?} */ infiniteScrollEvent: InfiniteScrollEvent = {\n        currentScrollPosition: container.scrolledUntilNow\n      };\n      if (scrollStats.isScrollingDown) {\n        this.onScrollDown(infiniteScrollEvent);\n      } else {\n        this.onScrollUp(infiniteScrollEvent);\n      }\n    }\n  }\n/**\n * @param {?} shouldScroll\n * @return {?}\n */\nshouldTriggerEvents(shouldScroll: boolean) {\n    return (this.alwaysCallback || shouldScroll) && !this.infiniteScrollDisabled;\n  }\n/**\n * @return {?}\n */\nngOnDestroy () {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n/**\n * @param {?=} data\n * @return {?}\n */\nonScrollDown(data: InfiniteScrollEvent = { currentScrollPosition: 0 }) {\n    this.zone.run(() => this.scrolled.emit(data));\n  }\n/**\n * @param {?=} data\n * @return {?}\n */\nonScrollUp(data: InfiniteScrollEvent = { currentScrollPosition: 0 }) {\n    this.zone.run(() => this.scrolledUp.emit(data));\n  }\n/**\n * @return {?}\n */\nprivate resolveContainerElement(): any {\n    const /** @type {?} */ selector = this.infiniteScrollContainer;\n    const /** @type {?} */ hasWindow = window && window.hasOwnProperty('document');\n    const /** @type {?} */ containerIsString = selector && hasWindow && typeof(this.infiniteScrollContainer) === 'string';\n    let /** @type {?} */ container = containerIsString\n      ? window.document.querySelector(selector)\n      : selector;\n    if (!selector) {\n      container = this.scrollWindow ? window : this.element;\n    }\n    return container;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: NgZone, },\n{type: PositionResolver, },\n{type: ScrollRegister, },\n{type: ScrollResolver, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'scrolled': [{ type: Output },],\n'scrolledUp': [{ type: Output },],\n'infiniteScrollDistance': [{ type: Input },],\n'infiniteScrollUpDistance': [{ type: Input },],\n'infiniteScrollThrottle': [{ type: Input },],\n'infiniteScrollDisabled': [{ type: Input },],\n'infiniteScrollContainer': [{ type: Input },],\n'scrollWindow': [{ type: Input },],\n'immediateCheck': [{ type: Input },],\n'horizontal': [{ type: Input },],\n'alwaysCallback': [{ type: Input },],\n'scrollUpBy': [{ type: Input },],\n};\n}\n\nfunction InfiniteScrollDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScrollDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScrollDirective.ctorParameters;\n/** @type {?} */\nInfiniteScrollDirective.propDecorators;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrolled;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrolledUp;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollDistance;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollUpDistance;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollThrottle;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollDisabled;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollContainer;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollWindow;\n/** @type {?} */\nInfiniteScrollDirective.prototype.immediateCheck;\n/** @type {?} */\nInfiniteScrollDirective.prototype.horizontal;\n/** @type {?} */\nInfiniteScrollDirective.prototype.alwaysCallback;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollUpBy;\n/** @type {?} */\nInfiniteScrollDirective.prototype.disposeScroller;\n/** @type {?} */\nInfiniteScrollDirective.prototype.element;\n/** @type {?} */\nInfiniteScrollDirective.prototype.zone;\n/** @type {?} */\nInfiniteScrollDirective.prototype.positionResolver;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollRegister;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollerResolver;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\n\nimport { InfiniteScrollDirective } from './infinite-scroll.directive';\nimport { PositionResolver } from '../services/position-resolver';\nimport { ScrollRegister } from '../services/scroll-register';\nimport { ScrollResolver } from '../services/scroll-resolver';\nexport class InfiniteScrollModule { static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [InfiniteScrollDirective],\n  exports: [InfiniteScrollDirective],\n  imports: [],\n  providers: [\n    PositionResolver,\n    ScrollRegister,\n    ScrollResolver\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction InfiniteScrollModule_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScrollModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScrollModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["PositionResolver","prototype","create","options","isWindow","this","isElementWindow","windowElement","axis","container","defineContainer","isContainerWindow","nativeElement","Object","toString","call","includes","getDocumentElement","document","documentElement","calculatePoints","element","resolver","calculatePointsForWindow","calculatePointsForElement","offsetHeightKey","clientHeightKey","height","topKey","scrolledUntilNow","pageYOffset","nativeElementHeight","totalToScroll","offsetTop","scrollTop","scrollTopKey","scrollHeight","scrollHeightKey","elem","isNaN","getBoundingClientRect","pageYOffsetKey","offsetTopKey","window","ownerDocument","defaultView","decorators","type","Injectable","ctorParameters","ScrollRegister","attachEvent","Observable","fromEvent","sampleTime","throttleDuration","filter","filterBefore","mergeMap","ev","of","subscribe","scrollHandler","ScrollResolver","lastScrollPosition","shouldScroll","config","scrollingDown","remaining","containerBreakpoint","distance","scrollUpBy","down","up","isScrollingDown","getScrollStats","AxisResolver","vertical","InfiniteScrollDirective","zone","positionResolver","scrollRegister","scrollerResolver","scrolled","EventEmitter","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","scrollWindow","immediateCheck","horizontal","alwaysCallback","ngOnInit","_this","runOutsideAngular","containerElement","resolveContainerElement","handleOnScroll","disposeScroller","scrollStats","shouldTriggerEvents","infiniteScrollEvent","currentScrollPosition","onScrollDown","onScrollUp","ngOnDestroy","unsubscribe","data","run","emit","selector","hasWindow","hasOwnProperty","containerIsString","querySelector","Directive","args","ElementRef","NgZone","propDecorators","Output","Input","InfiniteScrollModule","NgModule","declarations","exports","imports","providers"],"mappings":"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"}