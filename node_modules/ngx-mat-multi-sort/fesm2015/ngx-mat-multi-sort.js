import { Directive, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Optional, Inject, ElementRef, Input, HostListener, HostBinding, ViewChild, NgModule } from '@angular/core';
import { MatSort, MatSortHeader, matSortAnimations, MatSortHeaderIntl } from '@angular/material/sort';
import { FocusMonitor } from '@angular/cdk/a11y';
import { moveItemInArray, DragDropModule } from '@angular/cdk/drag-drop';
import { Subject, BehaviorSubject } from 'rxjs';
import { MatDialogRef, MAT_DIALOG_DATA, MatDialog, MatDialogModule } from '@angular/material/dialog';
import { finalize } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatCommonModule } from '@angular/material/core';
import { MatDividerModule } from '@angular/material/divider';
import { MatMenuModule } from '@angular/material/menu';
import { MatIconModule } from '@angular/material/icon';
import { MatTooltipModule } from '@angular/material/tooltip';
import { FormsModule } from '@angular/forms';
import { DataSource } from '@angular/cdk/collections';

class MatMultiSort extends MatSort {
    constructor() {
        super(...arguments);
        this.start = 'asc';
        this.actives = [];
        this.directions = [];
    }
    ngOnInit() {
        super.ngOnInit();
    }
    sort(sortable) {
        this.updateMultipleSorts(sortable);
        super.sort(sortable);
    }
    updateMultipleSorts(sortable) {
        const i = this.actives.findIndex(activeId => activeId === sortable.id);
        if (this.isActive(sortable)) {
            if (this.activeDirection(sortable) === (sortable.start ? sortable.start : this.start)) {
                this.directions.splice(i, 1, this.getNextSortDirection(sortable));
            }
            else {
                this.actives.splice(i, 1);
                this.directions.splice(i, 1);
            }
        }
        else {
            this.actives.push(sortable.id);
            this.directions.push(sortable.start ? sortable.start : this.start);
        }
    }
    isActive(sortable) {
        const i = this.actives.findIndex(activeId => activeId === sortable.id);
        return i > -1;
    }
    activeDirection(sortable) {
        const i = this.actives.findIndex(activeId => activeId === sortable.id);
        return this.directions[i] || (sortable.start ? sortable.start : this.start);
    }
}
MatMultiSort.decorators = [
    { type: Directive, args: [{
                selector: '[matMultiSort]',
                exportAs: 'matMultiSort'
            },] }
];

class MatMultiSortHeaderComponent extends MatSortHeader {
    constructor(_intl, changeDetectorRef, _sort, _columnDef, _focusMonitor, _elementRef) {
        super(_intl, changeDetectorRef, _sort, _columnDef, _focusMonitor, _elementRef);
        this._intl = _intl;
        this._sort = _sort;
        this._columnDef = _columnDef;
        this.start = 'asc';
    }
    __setIndicatorHintVisible(visible) {
        super._setIndicatorHintVisible(visible);
    }
    _handleClick() {
        this._sort.direction = this.getSortDirection();
        super._handleClick();
    }
    _isSorted() {
        return this._sort.actives.findIndex(activeId => activeId === this.id) > -1;
    }
    _sortId() {
        return this._sort.actives.findIndex(activeId => activeId === this.id) + 1;
    }
    _updateArrowDirection() {
        this._arrowDirection = this.getSortDirection();
    }
    _getAriaSortAttribute() {
        if (!this._isSorted()) {
            return null;
        }
        return this.getSortDirection() === 'asc' ? 'ascending' : 'descending';
    }
    _renderArrow() {
        return !this._isDisabled() || this._isSorted();
    }
    getSortDirection() {
        const i = this._sort.actives.findIndex(activeIds => activeIds === this.id);
        const direction = this._sort.directions[i];
        return this._isSorted() ? direction : (this.start || this._sort.start);
    }
}
MatMultiSortHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: '[mat-multi-sort-header]',
                exportAs: 'matMultiSortHeader',
                template: "<div class=\"mat-sort-header-container\"\r\n     [class.mat-sort-header-sorted]=\"_isSorted()\"\r\n     [class.mat-sort-header-position-before]=\"arrowPosition == 'before'\">\r\n  <button class=\"mat-sort-header-button\" type=\"button\"\r\n          [attr.disabled]=\"_isDisabled() || null\"\r\n          [attr.aria-label]=\"_intl.sortButtonLabel(id)\"\r\n          (focus)=\"_setIndicatorHintVisible(true)\"\r\n          (blur)=\"_setIndicatorHintVisible(false)\">\r\n    <ng-content></ng-content>\r\n  </button>\r\n\r\n  <!-- Disable animations while a current animation is running -->\r\n  <div class=\"mat-sort-header-arrow\"\r\n       *ngIf=\"_renderArrow()\"\r\n       [@arrowOpacity]=\"_getArrowViewState()\"\r\n       [@arrowPosition]=\"_getArrowViewState()\"\r\n       [@allowChildren]=\"_getArrowDirectionState()\"\r\n       (@arrowPosition.start)=\"_disableViewStateAnimation = true\"\r\n       (@arrowPosition.done)=\"_disableViewStateAnimation = false\">\r\n    <div class=\"mat-sort-header-stem\"></div>\r\n    <div class=\"mat-sort-header-indicator\" [@indicator]=\"_getArrowDirectionState()\">\r\n      <div class=\"mat-sort-header-pointer-left\" [@leftPointer]=\"_getArrowDirectionState()\"></div>\r\n      <div class=\"mat-sort-header-pointer-right\" [@rightPointer]=\"_getArrowDirectionState()\"></div>\r\n      <div class=\"mat-sort-header-pointer-middle\"></div>\r\n    </div>\r\n  </div>\r\n  <div *ngIf=\"_isSorted()\">{{_sortId()}}</div>\r\n</div>\r\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    matSortAnimations.indicator,
                    matSortAnimations.leftPointer,
                    matSortAnimations.rightPointer,
                    matSortAnimations.arrowOpacity,
                    matSortAnimations.arrowPosition,
                    matSortAnimations.allowChildren
                ],
                styles: [".mat-sort-header-container{align-items:center;cursor:pointer;display:flex}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{align-items:center;background:0 0;border:none;color:currentColor;cursor:inherit;display:flex;font:inherit;outline:0;padding:0}.mat-sort-header-button::-moz-focus-inner{border:0}.mat-sort-header-arrow{display:flex;height:12px;min-width:12px;opacity:0;position:relative;width:12px}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{align-items:center;background:currentColor;display:flex;height:10px;margin:auto;width:2px}.mat-sort-header-indicator{align-items:center;display:flex;height:2px;left:0;position:absolute;top:0;width:100%}.mat-sort-header-pointer-middle{background:currentColor;height:2px;margin:auto;transform:rotate(45deg);width:2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;height:2px;position:absolute;top:0;width:6px}.mat-sort-header-pointer-left{left:0;transform-origin:right}.mat-sort-header-pointer-right{right:0;transform-origin:left}"]
            },] }
];
MatMultiSortHeaderComponent.ctorParameters = () => [
    { type: MatSortHeaderIntl },
    { type: ChangeDetectorRef },
    { type: MatMultiSort, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Inject, args: ['C2_SORT_HEADER_COLUMN_DEF',] }, { type: Optional }] },
    { type: FocusMonitor },
    { type: ElementRef }
];
MatMultiSortHeaderComponent.propDecorators = {
    id: [{ type: Input, args: ['mat-multi-sort-header',] }],
    __setIndicatorHintVisible: [{ type: HostListener, args: ['mouseenter', ['true'],] }, { type: HostListener, args: ['longpress', ['true'],] }, { type: HostListener, args: ['mouseleave', ['false'],] }],
    _getAriaSortAttribute: [{ type: HostBinding, args: ['attr.aria-sort',] }]
};

class Settings {
    constructor(key) {
        this._key = key;
        this._columns = [];
        this._sortParams = [];
        this._sortDirs = [];
    }
    load() {
        const value = JSON.parse(localStorage.getItem(this._key));
        if (value) {
            this._columns = value._columns || [];
            this._sortDirs = value._sortDirs || [];
            this._sortParams = value._sortParams || [];
        }
    }
    save() {
        const settingsString = JSON.stringify(this);
        localStorage.setItem(this._key, settingsString);
    }
    get columns() {
        return this._columns;
    }
    get sortParams() {
        return this._sortParams;
    }
    get sortDirs() {
        return this._sortDirs;
    }
    get key() {
        return this._key;
    }
    set columns(columns) {
        this._columns = columns;
    }
    set sortParams(sortParams) {
        this._sortParams = sortParams;
    }
    set sortDirs(sortDirs) {
        this._sortDirs = sortDirs;
    }
}

class TableData {
    // TODO refactor
    constructor(columns, options) {
        this._nextObservable = new Subject();
        this._previousObservable = new Subject();
        this._sizeObservable = new Subject();
        this._sortObservable = new Subject();
        this._columns = new BehaviorSubject(columns.map(c => { if (c.isActive === undefined) {
            c.isActive = true;
        } return c; }));
        if (options) {
            if (options.pageSizeOptions && options.pageSizeOptions.length < 1) {
                throw Error('Array of pageSizeOptions must contain at least one entry');
            }
            if (options.defaultSortParams) {
                options.defaultSortParams.map(s => {
                    if (!this._displayedColumns.includes(s)) {
                        throw Error(`Provided sort parameter "${s}" is not a column.`);
                    }
                });
            }
            this._sortParams = options.defaultSortParams || [];
            this._sortDirs = options.defaultSortDirs || [];
            if (this._sortParams.length !== this._sortDirs.length) {
                this._sortDirs = this._sortParams.map(() => 'asc');
            }
            this._totalElements = options.totalElements || 0;
            this._pageSizeOptions = options.pageSizeOptions || [10, 20, 50, 100];
            this._key = options.localStorageKey;
        }
        else {
            this._pageSizeOptions = [10, 20, 50, 100];
            this._sortParams = [];
            this._sortDirs = [];
        }
        this.pageSize = this._pageSizeOptions[0];
        this.init();
        this._displayedColumns = this._columns.value.filter(c => c.isActive).map(c => c.id);
    }
    onSortEvent() {
        this._sortParams = this._dataSource.sort['actives'];
        this._sortDirs = this._dataSource.sort['directions'];
        this._clientSideSort();
        this._sortObservable.next();
        this.storeTableSettings();
    }
    onPaginationEvent($event) {
        const tmpPageSize = this.pageSize;
        this.pageSize = $event.pageSize;
        this.pageIndex = $event.pageIndex;
        if (tmpPageSize !== this.pageSize) {
            this._sizeObservable.next();
        }
        else if ($event.previousPageIndex < $event.pageIndex) {
            this._nextObservable.next();
        }
        else if ($event.previousPageIndex > $event.pageIndex) {
            this._previousObservable.next();
        }
    }
    updateSortHeaders() {
        // Dirty hack to display default sort column(s)
        const temp = Object.assign([], this._displayedColumns);
        this._displayedColumns = [];
        setTimeout(() => this._displayedColumns = temp, 0);
        this._clientSideSort();
        this._sortObservable.next();
        this.storeTableSettings();
        1;
    }
    init() {
        console.debug("init");
        if (this._key) {
            const settings = new Settings(this._key);
            settings.load();
            if (this._isLocalStorageSettingsValid(settings)) {
                this.columns = settings.columns;
                this._sortDirs = settings.sortDirs;
                this._sortParams = settings.sortParams;
            }
            else {
                console.warn("Stored tableSettings are invalid. Using default");
            }
        }
    }
    _clientSideSort() {
        this._dataSource.orderData();
    }
    _isLocalStorageSettingsValid(settings) {
        // check if number of columns matching
        if (settings.columns.length !== this._columns.value.length) {
            return false;
        }
        // check if columns are the same
        for (var column of settings.columns) {
            var match = this._columns.value.filter(c => c.id == column.id && c.name == column.name);
            if (match === undefined) {
                return false;
            }
        }
        return true;
    }
    storeTableSettings() {
        console.log("Store");
        if (this._key) {
            const settings = new Settings(this._key);
            settings.columns = this._columns.value;
            settings.sortParams = this._sortParams;
            settings.sortDirs = this._sortDirs;
            settings.save();
        }
    }
    set totalElements(totalElements) {
        this._totalElements = totalElements;
    }
    get totalElements() {
        return this._totalElements;
    }
    set displayedColumns(displayedColumns) {
        this._displayedColumns = displayedColumns;
    }
    get displayedColumns() {
        return this._displayedColumns;
    }
    set dataSource(dataSource) {
        this._dataSource = dataSource;
        if (this._sortParams.length > 0) {
            this._dataSource.sort.actives = this._sortParams;
            this._dataSource.sort.directions = this._sortDirs.map(v => v);
            this.updateSortHeaders();
        }
    }
    get dataSource() {
        return this._dataSource;
    }
    set data(data) {
        this._dataSource.data = data;
        this._clientSideSort();
    }
    set columns(v) {
        this._columns.next(v.map(c => { if (c.isActive === undefined) {
            c.isActive = true;
        } return c; }));
    }
    onColumnsChange() {
        return this._columns;
    }
    updateColumnNames(v) {
        const dict = {};
        v.forEach(c => dict[c.id] = c.name);
        this._columns.next(this._columns.value.map(c => { c.name = dict[c.id] || c.name; return c; }));
    }
    get nextObservable() {
        return this._nextObservable;
    }
    get previousObservable() {
        return this._previousObservable;
    }
    get sizeObservable() {
        return this._sizeObservable;
    }
    get sortObservable() {
        return this._sortObservable;
    }
    get sortParams() {
        return this._sortParams;
    }
    get sortDirs() {
        return this._sortDirs;
    }
    get columns() {
        return this._columns.value;
    }
    get pageSizeOptions() {
        return this._pageSizeOptions;
    }
    set sortParams(v) {
        this._sortParams = v;
        this._dataSource.sort.actives = this._sortParams;
    }
    set sortDirs(v) {
        this._sortDirs = v;
        this._dataSource.sort.directions = this._sortDirs.map(elem => elem);
    }
}

class MatMultiSortColumnDialogComponent {
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.sort = [];
        this._tableData = data.tableData;
        this.sort = data.sort;
        this.closeOnChoice = data.closeOnChoice;
    }
    ngOnInit() {
    }
    drop(event) {
        moveItemInArray(this._tableData.columns, event.previousIndex, event.currentIndex);
        this._tableData.displayedColumns = this._tableData.columns.filter(c => c.isActive).map(c => c.id);
        this._tableData.storeTableSettings();
    }
    toggle() {
        this._tableData.displayedColumns = this._tableData.columns.filter(c => {
            if (!c.isActive) {
                this.sort = this.sort.filter(s => s.id !== c.id);
            }
            return c.isActive;
        }).map(c => c.id);
        this.updateSort();
    }
    updateSort() {
        this._tableData.sortParams = this.sort.map(v => v.id);
        this._tableData.sortDirs = this.sort.map(v => v.direction);
        this._tableData.updateSortHeaders();
        if (this.closeOnChoice) {
            this.dialogRef.close();
        }
    }
}
MatMultiSortColumnDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-multi-sort-column-dialog',
                template: "<div cdkDropList class=\"example-list\" (cdkDropListDropped)=\"drop($event)\">\r\n  <div class=\"example-box\" *ngFor=\"let column of _tableData.columns\" cdkDrag>\r\n    <mat-icon>drag_indicator</mat-icon>\r\n    <mat-checkbox [(ngModel)]=\"column.isActive\" (change)=\"toggle()\">{{column.name}}</mat-checkbox>\r\n  </div>\r\n</div>\r\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".column-dialog .mat-dialog-container{padding:0}.example-box{align-items:center;display:flex;height:48px;justify-content:flex-start;margin:1px;padding:0 16px 0 8px}.example-box mat-icon{margin-right:16px}.example-box mat-checkbox{color:rgba(0,0,0,.87);font-size:14px;font-weight:400;line-height:48px}.example-box:hover{border-bottom:1px solid rgba(0,0,0,.12);border-top:1px solid rgba(0,0,0,.12);cursor:move}.my-menu:hover{cursor:move}.cdk-drag-preview{border-radius:4px;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-sizing:border-box}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating{transition:transform .25s cubic-bezier(0,0,.2,1)}.example-box:last-child{border:none}.example-list.cdk-drop-list-dragging .example-box:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"]
            },] }
];
MatMultiSortColumnDialogComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class MatMultiSortTableSettingsComponent {
    constructor(dialog) {
        this.dialog = dialog;
        this.sort = [];
        this.closeDialogOnChoice = true;
    }
    set tableData(tableData) {
        this._tableData = tableData;
    }
    ngOnInit() {
        this.sort = this.getSort();
        this._tableData.sortObservable.subscribe(() => this.sort = this.getSort());
        this._tableData.onColumnsChange().subscribe(() => this.sort = this.getSort());
    }
    openDialog() {
        if (this.dialogRef) {
            return;
        }
        const button = this.buttonRef.nativeElement;
        const posRight = window.innerWidth - (button.offsetLeft + button.offsetWidth + 16);
        const posTop = button.offsetTop + button.offsetHeight;
        this.dialogRef = this.dialog.open(MatMultiSortColumnDialogComponent, {
            backdropClass: 'cdk-overlay-transparent-backdrop',
            panelClass: 'column-dialog',
            position: { right: `${posRight}px`, top: `${posTop}px` },
            data: { tableData: this._tableData, sort: this.sort, closeOnChoice: this.closeDialogOnChoice }
        });
        this.dialogRef.backdropClick().subscribe(() => this.dialogRef.close());
        this.dialogRef.afterClosed().pipe(finalize(() => this.dialogRef = null)).subscribe();
    }
    dropSort(event) {
        moveItemInArray(this.sort, event.previousIndex, event.currentIndex);
        this.updateSort();
    }
    getSort() {
        const sorting = [];
        for (let i = 0; i < this._tableData.sortParams.length; i++) {
            sorting.push({
                id: this._tableData.sortParams[i],
                name: this._tableData.columns.find(c => c.id === this._tableData.sortParams[i]).name,
                direction: this._tableData.sortDirs[i]
            });
        }
        return sorting;
    }
    remove(id) {
        this.sort = this.sort.filter(v => v.id !== id);
        this.updateSort();
    }
    updateDirection(id) {
        const i = this.sort.findIndex(v => v.id === id);
        if (this.sort[i].direction === 'asc') {
            this.sort[i].direction = 'desc';
        }
        else {
            this.sort[i].direction = 'asc';
        }
        this.updateSort();
    }
    updateSort() {
        this._tableData.sortParams = this.sort.map(v => v.id);
        this._tableData.sortDirs = this.sort.map(v => v.direction);
        this._tableData.updateSortHeaders();
    }
}
MatMultiSortTableSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-multi-sort-table-settings',
                template: "<div class=\"table-settings\">\r\n    <div class=\"table-settings-sort\">\r\n        <mat-chip-list class=\"drag-chip-list\" cdkDropList cdkDropListOrientation='horizontal'\r\n            (cdkDropListDropped)=\"dropSort($event)\">\r\n            <mat-chip class=\"drag-chip\" *ngFor=\"let item of sort\" cdkDrag (removed)=\"remove(item.id)\"\r\n                (click)=\"updateDirection(item.id)\">\r\n                {{item.name}}:\r\n                <div class=\"sorting\" [matTooltip]=\"sortToolTip\">\r\n                    {{item.direction}}\r\n                </div>\r\n                <mat-icon matChipRemove>cancel</mat-icon>\r\n            </mat-chip>\r\n        </mat-chip-list>\r\n    </div>\r\n    <div style=\"flex: 1 1 auto;\"></div>\r\n    <div #settingsMenu (click)=\"openDialog()\" class=\"table-settings-menu\">\r\n        <ng-content #menuRef></ng-content>\r\n    </div>\r\n</div>\r\n",
                styles: [".table-settings{display:flex}.table-settings .table-settings-menu{margin:8px 16px}.table-settings-sort{margin:auto 0}.sorting{color:#757575;display:inline-block;margin:0 6px}.sorting:hover{cursor:pointer}.drag-chip{background-color:#fff;border:1px solid rgba(0,0,0,.12)}.drag-chip:hover{background-color:#fff;cursor:move}.drag-chip:focus:after,.drag-chip:hover:after{opacity:0}.drag-chip-list.cdk-drop-list-dragging .drag-chip:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"]
            },] }
];
MatMultiSortTableSettingsComponent.ctorParameters = () => [
    { type: MatDialog }
];
MatMultiSortTableSettingsComponent.propDecorators = {
    buttonRef: [{ type: ViewChild, args: ['settingsMenu',] }],
    sortToolTip: [{ type: Input }],
    closeDialogOnChoice: [{ type: Input }],
    tableData: [{ type: Input }]
};

class MatMultiSortModule {
}
MatMultiSortModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    MatMultiSortHeaderComponent,
                    MatMultiSort,
                    MatMultiSortTableSettingsComponent,
                    MatMultiSortColumnDialogComponent
                ],
                exports: [
                    MatMultiSortHeaderComponent,
                    MatMultiSort,
                    MatMultiSortTableSettingsComponent
                ],
                imports: [
                    CommonModule,
                    MatCommonModule,
                    MatDividerModule,
                    DragDropModule,
                    MatIconModule,
                    MatCheckboxModule,
                    MatMenuModule,
                    MatButtonModule,
                    FormsModule,
                    MatChipsModule,
                    MatTooltipModule,
                    MatDialogModule
                ]
            },] }
];

class MatMultiSortTableDataSource extends DataSource {
    constructor(sort, clientSideSorting = false) {
        super();
        this._data = new BehaviorSubject([]);
        this.sort = sort;
        this.clientSideSorting = clientSideSorting;
    }
    set data(data) {
        this._data.next(data);
    }
    get data() {
        return this._data.value;
    }
    connect() {
        return this._data;
    }
    disconnect() {
        this._data.complete();
    }
    orderData() {
        this._data.next(this.sortData(this._data.value, this.sort.actives, this.sort.directions));
    }
    sortData(data, actives, directions) {
        const _data = Object.assign(new Array(), data);
        if (this.clientSideSorting) {
            return _data.sort((i1, i2) => {
                return this._sortData(i1, i2, actives, directions);
            });
        }
        return _data;
    }
    _sortData(d1, d2, params, dirs) {
        if (d1[params[0]] > d2[params[0]]) {
            return dirs[0] === 'asc' ? 1 : -1;
        }
        else if (d1[params[0]] < d2[params[0]]) {
            return dirs[0] === 'asc' ? -1 : 1;
        }
        else {
            if (params.length > 1) {
                params = params.slice(1, params.length);
                dirs = dirs.slice(1, dirs.length);
                return this._sortData(d1, d2, params, dirs);
            }
            else {
                return 0;
            }
        }
    }
}

/*
 * Public API Surface of mat-multi-sort
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MatMultiSort, MatMultiSortHeaderComponent, MatMultiSortModule, MatMultiSortTableDataSource, MatMultiSortTableSettingsComponent, TableData, MatMultiSortColumnDialogComponent as ɵa };
//# sourceMappingURL=ngx-mat-multi-sort.js.map
